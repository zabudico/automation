# Лабораторная работа №4: Настройка Jenkins для автоматизации задач DevOps

## Описание проекта
В данной лабораторной работе я настроил среду автоматизации CI/CD с использованием Jenkins. Проект включал в себя настройку Jenkins Controller и SSH Agent с помощью Docker Compose, создание и настройку pipeline для PHP проекта с unit-тестами.

Основные цели работы:
- Изучить принципы работы Jenkins и его компонентов
- Настроить автоматизированный pipeline для тестирования PHP приложения
- Освоить практики DevOps для автоматизации процессов сборки и тестирования

## Шаги настройки Jenkins Controller

### 1. Создание docker-compose.yml
Я создал файл `docker-compose.yml` с конфигурацией для сервиса Jenkins Controller. В файле определил сервис `jenkins-controller` на основе образа `jenkins/jenkins:lts`, пробросил порты 8080 и 50000, настроил volume для хранения данных Jenkins и подключил сервис к сети `jenkins-network`.

### 2. Запуск и первоначальная настройка
Я запустил контейнер Jenkins с помощью команды `docker-compose up -d jenkins-controller`. После запуска выполнил первоначальную настройку через веб-интерфейс по адресу `http://localhost:8080`.

**[СКРИНШОТ 1: Веб-интерфейс Jenkins при первоначальной настройке]**

### 3. Получение начального пароля
Начальный пароль администратора я получил из логов контейнера с помощью команды `docker logs jenkins-controller`.

## Шаги настройки SSH Agent

### 1. Генерация SSH ключей
В папке `secrets` я сгенерировал SSH ключи с помощью команды `ssh-keygen -f jenkins_agent_ssh_key`.

### 2. Создание Dockerfile
Я создал Dockerfile для SSH агента с установкой PHP-CLI, чтобы на агенте можно было запускать PHP скрипты и тесты.

### 3. Конфигурация SSH Agent в docker-compose.yml
Я добавил в файл `docker-compose.yml` конфигурацию для сервиса `ssh-agent`. Указал сборку из Dockerfile, передачу публичного ключа через переменную окружения, подключение volume и сети, а также зависимость от сервиса `jenkins-controller`.

### 4. Создание .env файла
Я создал файл `.env` и поместил в него публичный SSH ключ, чтобы он был доступен в контейнере SSH агента.

**[СКРИНШОТ 2: Структура папки проекта с secrets, docker-compose.yml и .env файлом]**

## Шаги создания и настройки Jenkins Pipeline

### 1. Подключение SSH Agent к Jenkins

#### Проверка плагина SSH Agents
В веб-интерфейсе Jenkins я проверил, установлен ли плагин "SSH Agents Plugin". Плагин был уже установлен, поэтому дополнительных действий не потребовалось.

**[СКРИНШОТ 3: Раздел управления плагинами в Jenkins]**

#### Регистрация SSH ключей
В разделе Manage Jenkins > Manage Credentials я добавил новый SSH ключ с типом "SSH Username with private key", указал имя пользователя `jenkins` и вставил содержимое приватного ключа из файла `secrets/jenkins_agent_ssh_key`.

**[СКРИНШОТ 4: Настройки Credentials в Jenkins]**

#### Добавление узла агента
Я создал новый узел с именем `ssh-agent1`, типом "Permanent Agent", с меткой `php-agent`. Указал remote root directory как `/home/jenkins/agent`, launch method "Launch agents via SSH", хост `ssh-agent` и выбрал ранее добавленные credentials.

**[СКРИНШОТ 5: Настройки узла ssh-agent1 в Jenkins]**

### 2. Создание Pipeline

#### Выбор PHP проекта
Для pipeline я выбрал PHP проект `php_arrays`, который содержит 17 unit-тестов. Этот проект был ранее разработан в рамках курса по PHP программированию.

#### Создание Jenkinsfile
Я создал Jenkinsfile в папке `lab04/php_arrays` со следующим pipeline:
- Стадия Checkout: клонирование репозитория
- Стадия Code Quality: проверка синтаксиса PHP файлов
- Стадия Run Tests: запуск unit-тестов

### 3. Настройка Pipeline в Jenkins
В Jenkins я создал новый проект типа Pipeline. Указал, что pipeline будет загружаться из SCM (Git), указал URL своего репозитория и путь к Jenkinsfile: `lab04/php_arrays/Jenkinsfile`.

**[СКРИНШОТ 6: Настройки Pipeline в Jenkins]**

### 4. Результаты выполнения
После настройки я запустил pipeline и убедился, что все стадии выполняются без ошибок. Все 17 unit-тестов были пройдены успешно.

**[СКРИНШОТ 7: Успешное выполнение Pipeline со всеми пройденными тестами]**

## Ответы на вопросы

### Каковы преимущества использования Jenkins для автоматизации задач DevOps?

1. **Автоматизация процессов**: Jenkins позволяет автоматизировать этапы сборки, тестирования и развертывания, что значительно ускоряет процесс разработки и повышает надежность.

2. **Интеграция с инструментами**: Благодаря богатой экосистеме плагинов, Jenkins легко интегрируется с различными инструментами и технологиями (Git, Docker, Kubernetes и т.д.).

3. **Масштабируемость**: Возможность распределения нагрузки на несколько агентов позволяет обрабатывать множество задач параллельно.

4. **Отслеживание и мониторинг**: Jenkins предоставляет детальную информацию о выполнении задач, историю сборок и удобную визуализацию, что упрощает отслеживание проблем.

5. **Гибкость**: Поддержка различных языков программирования и технологий через конвейеры (pipelines) и плагины делает Jenkins универсальным инструментом.

### Какие существуют другие типы агентов Jenkins?

1. **Docker Agents**: Запускают задания в изолированных Docker-контейнерах, что обеспечивает чистоту окружения для каждой сборки.

2. **Kubernetes Agents**: Динамически создают поды (pods) в Kubernetes кластере для выполнения заданий, обеспечивая высокую масштабируемость.

3. **Windows Agents**: Специализированные агенты для выполнения заданий на Windows-машинах, необходимые для Windows-специфичных задач.

4. **SSH Agents**: Подключаются к удаленным машинам по SSH протоколу для выполнения заданий, как было продемонстрировано в данной работе.

5. **JNLP Agents**: Запускаются с помощью Java Web Start (JNLP) и подключаются к Jenkins мастеру, обеспечивая гибкость в настройке.

6. **Cloud Agents**: Динамически создаются в облачных провайдерах (AWS, Azure, GCP) для временного выполнения задач.

### С какими проблемами вы столкнулись при настройке Jenkins и как их решили?

1. **Проблема**: Ошибка формата .env файла в Windows
   **Решение**: Я использовал правильные команды PowerShell для создания файла без лишних кавычек и специальных символов.

2. **Проблема**: Ошибка синтаксиса в Jenkinsfile из-за неправильного экранирования символов
   **Решение**: Я упростил Jenkinsfile, заменив проблемные команды с экранированием на более простые альтернативы с использованием `xargs`.

3. **Проблема**: Неправильный URL репозитория в настройках Pipeline
   **Решение**: Я указал корректный URL репозитория automation вместо неправильного пути к подпапке.

4. **Проблема**: Агент не подключался к Jenkins
   **Решение**: Я проверил корректность SSH ключей, убедился в правильности настроек сети в docker-compose и пересоздал credentials в Jenkins.

5. **Проблема**: Команды не выполнялись в правильной директории
   **Решение**: Я использовал блок `dir()` в Jenkinsfile для явного указания рабочей директории.

## Заключение

В результате лабораторной работы я успешно настроил среду Jenkins с использованием Docker Compose, создал и запустил pipeline для автоматического тестирования PHP проекта. Все этапы pipeline выполняются корректно, unit-тесты проходят успешно. Работа демонстрирует эффективность использования Jenkins для автоматизации задач DevOps и может служить основой для более сложных CI/CD процессов.

**[СКРИНШОТ 8: Финальный успешный статус Pipeline с зеленой иконкой]**